
## wordReviewRecords

- 【现状描述】
  - 前端（IndexedDB/Dexie）
    - 表结构（v9）：主键 `++id`，唯一 `&uuid`，唯一 `&word`；索引字段：`nextReviewAt`、`currentIntervalIndex`、`isGraduated`、`todayPracticeCount`、`lastPracticedAt`、`lastReviewedAt`、`sync_status`、`last_modified`。
    - Type：`IWordReviewRecord` 包含 `word`、`intervalSequence`、`currentIntervalIndex`、`nextReviewAt`、`totalReviews`、`isGraduated`、`reviewHistory`、`consecutiveCorrect`、`lastReviewedAt`、`todayPracticeCount`、`lastPracticedAt`、`sourceDicts`、`preferredDict`、`firstSeenAt`、`sync_status`、`last_modified` 等。
  - 后端（MongoDB/Mongoose）
    - `IWordReviewRecord`：`uuid`、`userId`、`word`、`intervalSequence`、`currentIntervalIndex`、`isGraduated`、`nextReviewAt: Date`、`totalReviews`、`consecutiveCorrect`、`lastReviewResult`、`todayPracticeCount`、`lastPracticedAt: Date`、`sourceDicts`、`preferredDict`、`firstSeenAt: Date`、`lastReviewedAt: Date`、`sync_status`、`last_modified: number`、`clientModifiedAt: Date`、`isDeleted`。唯一索引 `(userId, word)`。
  - 同步（前端 `syncService.ts` + 服务端 `syncController.ts`）
    - 以 `uuid` 幂等 upsert；客户端与服务端在日期类型（number vs Date）之间转换；必要时通过 `word` 回填本地 `uuid`。

- 【发现的问题】
  - Dexie v9 表结构缺失字段：未包含 `userId`、`intervalSequence`、`totalReviews`、`reviewHistory`、`consecutiveCorrect`、`sourceDicts`、`preferredDict`、`firstSeenAt` 等（接口已定义但 stores 未声明索引/字段），易触发 Dexie SchemaDiff 警告，且导致索引查询性能受限。
  - 类型不一致：客户端多数时间戳为 `number`，服务端为 `Date`；`last_modified` 在此模型为 `number`，但其他模型有的用 `Date`（跨模型不统一）。
  - 以 `word` 回填本地 `uuid` 的逻辑存在误配风险（理论上每用户每词唯一，但若出现异常或并发，可能错绑）。
  - 未存储 `userId` 于本地，复查/去重/分用户清理时不够稳健。

- 【可能的后果】
  - SchemaDiff 或查询缺索引导致本地读写/升级异常；
  - 合并/回填 uuid 误绑，带来跨记录污染；
  - 长期性能隐患：无法按 `intervalSequence`、`totalReviews`、`sourceDicts` 等字段高效查询/排序。

- 【优化建议】
  - 定义 Dexie v10：为 `wordReviewRecords` 完整声明字段与索引（至少索引：`&uuid`、`&word`、`nextReviewAt`、`lastReviewedAt`、`currentIntervalIndex`、`isGraduated`、`preferredDict`、`last_modified`），并在 `upgrade()` 填充默认值。
  - 本地存储引入 `userId` 字段（用于多账号/切换场景的分区与清理）。
  - 去除“通过 word 回填 uuid”的旁路；强制以 `uuid` 幂等，找不到直接创建，并在 UI 层修复松散映射。
  - 统一时间类型转换：前端 number、服务端 Date，在同步边界统一转换。

## reviewHistories

- 【现状描述】
  - 前端（IndexedDB）：`IReviewHistory` 含 `uuid`、`userId?`、`wordReviewRecordId: number`（与本地 `wordReviewRecords.id` 关联）、`word`、`dict`、`reviewedAt`、`reviewResult`、`responseTime`、`intervalProgressBefore/After`、`intervalIndexBefore/After`、`reviewType`、`sessionId?`、`sync_status`、`last_modified`。
  - 后端（Mongoose）：`wordReviewRecordId: ObjectId`（指向服务端 `WordReviewRecord`），其余字段对应，但类型为 `Date/Number` 的组合；有多列索引：`userId+reviewedAt`、`userId+word+reviewedAt`、`userId+sessionId`、`userId+reviewResult+reviewedAt`。
  - 同步：上传时将本地 `wordReviewRecordId(number)` 转为服务端 `wordReviewRecord.uuid`；下载时再反查本地 `word` 找到 `id` 回填。

- 【发现的问题】
  - 外键映射脆弱：上传依赖由 `word` 找到服务端记录；下载再以 `word` 回找本地 `id`。一旦本地/服务端 `wordReviewRecords` 不一致，或 `word` 重名场景（理论上用户内唯一，但异常/竞态可破坏），会丢失关联或错绑。
  - Dexie schema 未声明更细查询索引（如 `reviewedAt`、`dict` 组合），长尾分析查询会退化为全表扫描。
  - 字段命名/类型方面基本统一，但 `sessionId` 使用上未见全链路严格保证（易空/易散）。

- 【可能的后果】
  - 历史关联断裂，统计口径异常；
  - 大表（高频写入）下的查询性能瓶颈；
  - 同步过程因找不到映射而丢弃变更。

- 【优化建议】
  - 在 Dexie `reviewHistories` 增加索引：`[wordReviewRecordId+reviewedAt]`、`[dict+reviewedAt]`、`[word+reviewedAt]`。
  - 同步时不再用 `word` 回填，改为“客户端首次创建 history 时附带 `parentUuid`（指向 wordReviewRecord.uuid）”；上传直接以 `parentUuid` 关联；下载也以 `parentUuid` 在本地 `wordReviewRecords` 上查 `uuid→id`，杜绝模糊匹配。
  - 引入“史料不可变”策略：history 仅写入新增，不做更新（除软删除），避免回放复杂度。

## wordRecords

- 【现状描述】
  - 前端：`IWordRecord` 新结构使用 `performanceHistory: { timeStamp:number, chapter:number|null, timing:number[], wrongCount:number, mistakes:Record<number,string[]> }[]`，并带 `firstSeenAt?`、`lastPracticedAt?`、`sync_status`、`last_modified`。Dexie v8/v9 stores 使用 `&uuid, &[dict+word], dict, word, lastPracticedAt, sync_status, last_modified`。
  - 后端：`IWordRecord` 使用 `performanceHistory.timeStamp: Date`，并唯一索引 `(userId, dict, word)`。
  - 同步：服务端将 `performanceHistory` 中的 `Date` 转 `number` 下发；接收客户端时将 `number` 转 `Date`，并做 `mistakes` 兜底。

- 【发现的问题】
  - 前后端时间类型不统一（number vs Date）可控，但缺少对 `performanceHistory` 的“去重键”（目前依赖 `timeStamp` 毫秒精度，理论上可能冲突）。
  - Dexie stores 未索引 `firstSeenAt/lastPracticedAt`，某些排序/过滤场景退化。
  - 服务端/客户端对废弃旧字段（`timeStamp/chapter/timing/wrongCount/mistakes` 顶层）的清理已做，但历史数据若残留易引发校验/迁移痛点。

- 【可能的后果】
  - 极端情况下同毫秒时间戳导致重复；
  - 大量历史记录条件查询慢；
  - 迁移时 Mixed 类型的 `mistakes` 容易触发校验异常。

- 【优化建议】
  - 为 `performanceHistory` 引入 `entryUuid`（客户端生成）作为去重键；服务端合并时以 `entryUuid` 或 `(timeStamp, wrongCount, len(timing))` 复合键去重。
  - Dexie 增加索引：`lastPracticedAt`、`[dict+lastPracticedAt]`。
  - 在同步入库前，统一给 `mistakes` 设空对象默认值（前端已做，后端也保持防御式）。

## chapterRecords

- 【现状描述】
  - 前端：`IChapterRecord` 包含 `uuid`、`dict`、`chapter:number|null`、`timeStamp:number`、`time:number`、`correctCount`、`wrongCount`、`wordCount`、`correctWordIndexes:number[]`、`wordNumber`、`wordRecordIds:number[]`、`sync_status`、`last_modified`。Dexie v8/v9 stores 已声明 `dict, chapter, timeStamp, sync_status, last_modified` 索引。
  - 后端：`ChapterRecord` 有 `id:number`（本地 id 回传）、`timeStamp:Date`、`last_modified:Date`、`clientModifiedAt:Date`、`serverModifiedAt:Date`，以及其他整型/数组字段；索引 `(userId, updatedAt)`、`(dict, chapter)`。

- 【发现的问题】
  - `last_modified` 在服务端用 `Date`；其他集合有用 `number`。同名字段跨集合类型不统一。
  - 回传 `id:number`（客户端自增 id）存入服务端价值有限且可能冲突（只是客户端内部键）。
  - Dexie 未对 `wordCount`、`wrongCount` 等分析场景做索引，统计面会成本较高。

- 【可能的后果】
  - 同步/比对时字段类型转换不一致导致 Bug；
  - 依赖客户端 id 的场景产生混淆；
  - 大量章节记录统计查询慢。

- 【优化建议】
  - 统一 `last_modified` 为 `number`（客户端）+ `clientModifiedAt: Date`（服务端显示存储），并在所有集合保持一致语义。
  - 移除上传时的 `id:number` 字段或改名为 `clientLocalId` 并不入索引。
  - Dexie 追加索引：`[dict+chapter+timeStamp]` 或至少 `timeStamp` 以便时间序排序。

## familiarWords

- 【现状描述】
  - 前端：`IFamiliarWord` 有 `uuid`、`word`、`dict`、`isFamiliar`、`sync_status`、`last_modified`；Dexie stores 有 `&uuid, dict, word, sync_status, last_modified, [dict+word]`。
  - 后端：`FamiliarWord` 复合唯一索引 `(userId, dict, word)`，`sync_status` 为枚举，含 `serverModifiedAt` 等服务端时间字段。

- 【发现的问题】
  - 前端未含 `userId` 字段（也无形成歧义，但对多用户切换本地隔离不友好）。
  - 同步时对 `familiarWords` 做了额外去重（前端在本地构建 `[dict+word]` 最新记录），逻辑合理，但未落地唯一约束到 Dexie（仅二级索引而非唯一）。

- 【可能的后果】
  - 账号切换/多账号同设备时清理隔离复杂；
  - 异常情况下可能出现本地重复（虽有去重逻辑，但并非约束）。

- 【优化建议】
  - Dexie 增加唯一索引能力（可通过 `&[dict+word]`，若 Dexie 版本/场景允许），否则在写入侧统一 upsert 策略（find→put）。
  - 本地记录冗余清理作业（定期扫描重复 `[dict+word]`）。

## reviewRecords

- 【现状描述】
  - 前端：`IReviewRecord` 有 `uuid`、`dict`、`index`、`createTime:number`、`isFinished:boolean`、`words: Word[]`、`sync_status`、`last_modified`。但 Dexie v8/v9 stores 使用了 `timeStamp` 字段名（与 `createTime` 命名不一致）。
  - 后端：`ReviewRecord` 的 `createTime: Date`，有 `(userId, createTime)` 索引。
  - 同步：无特别定制逻辑（标准表）。

- 【发现的问题】
  - 字段命名不一致：前端接口写 `createTime`，Dexie stores 写 `timeStamp`，服务端为 `createTime: Date`。这会造成入库/出库字段不一致、查询混乱。
  - `words:any[]`（服务端）类型宽泛，长期约束缺失（可引入 schema 校验）。

- 【可能的后果】
  - 线上难以排查的“空字段/错字段”问题；
  - 长期扩展性受限（`words` 无结构约束）。

- 【优化建议】
  - 统一字段为 `createTime`（客户端 number，服务端 Date），并在 Dexie v10 修正 stores 字段名。
  - 为 `words` 引入受控结构（如 `{ text:string, source:string, weight?:number }[]`），避免 `any[]` 的任意性。

---

## 通用维度

- 【数据存储方式】
  - 本地：IndexedDB（主存），localStorage（`token`、`lastSyncTimestamp`、`syncStats`、部分配置），内存（Jotai/Zustand）。
  - 云端：MongoDB；静态词典与媒体走静态资源。
  - 问题与后果：
    - localStorage 持 token（XSS 风险）；多处写入 sync 状态且分散；
    - Dexie 版本期望固定为 v9（`checkAndUpgradeDatabase()`），与“缺失字段”的 issue 建议 v10 升级不一致，易遗留旧结构。
  - 建议：
    - 引入 `APP_DATA_VERSION` 本地哨兵（不匹配即清库重建），配合 Dexie v10；
    - token 建议改为 HttpOnly Cookie 或最少做 CSP + 严格输入净化；
    - 统一一个 `syncState` 存储键（对象化），避免多处散落。

- 【数据同步机制】
  - 现状：先下后上、批量 upsert、按 `uuid` 幂等；特殊表做字段转换（`reviewHistories` 的外键，`wordRecords.performanceHistory.mistakes` 兜底）。
  - 问题与后果：
    - 跨表外键基于 `word` 的回填存在错绑风险；
    - `expectedVersion=9` 固定，无法自动推进到修复后的新版本；
  - 建议：
    - 用 `parentUuid` 替代 `word` 做历史外键联动；
    - 升级到 v10，完善 `wordReviewRecords` schema，升级脚本填充默认值；
    - 在服务端对老客户端（旧 schema）加“版本拒写”，避免回退污染。

- 【数据流与访问路径】
  - 现状：组件/Hook→Store→Dexie；同步服务→API `/api/sync`；无全量拉取（按变更流）。
  - 问题与后果：
    - 部分列表/统计页面可能做全表扫描（缺索引）；
  - 建议：
    - 为高频筛选字段补充索引（上述逐表建议）；
    - 大列表分页游标化，避免一次性全量遍历。

- 【安全与一致性】
  - 现状：JWT 放 localStorage；HTTPS 传输假设；服务端鉴权中间件齐全。
  - 问题与后果：XSS 夺取 token 风险；数据静态加密缺失（可选）。
  - 建议：HttpOnly Cookie + 短期 Refresh Token；关键集合增添审计字段或审计集合（谁在何时改了什么）。

- 【潜在隐患与不足】
  - 命名不统一（`createTime` vs `timeStamp`、`last_modified` 类型不一致）；
  - Dexie v9 与接口/服务端模型脱节；
  - 外键映射脆弱（以 `word` 回填）；
  - 大表索引不足导致性能隐患。

- 【优化建议（落地清单）】
  - Dexie v10：全表字段/索引对齐 + 升级脚本补默认值；
  - 统一命名与类型：时间戳前端 number、服务端 Date；`createTime` 统一命名；`last_modified:number` + `clientModifiedAt:Date`；
  - 同步协议：历史外键以 `parentUuid` 代替 `word`；禁用“以 word 回填 uuid”；
  - 性能：为查询热点字段建索引，避免全表扫描；
  - 安全：token 从 localStorage 迁移到 HttpOnly Cookie，或至少加 CSP/子资源完整性与严格输入净化；
  - 版本治理：APP_DATA_VERSION 哨兵 + 服务端版本拒写策略，避免回退污染。

- 可选快捷路径（历史数据不重要时）
  - 首次启动检测版本不符：清空 IndexedDB 全量重建；
  - 服务端清空这些集合（保留用户与官方数据）：`wordReviewRecords`、`reviewHistories`、`wordRecords`、`chapterRecords`、`familiarWords`、`reviewRecords`；
  - 以 v10 统一后的 schema 重新开始，同步协议即刻简化。

- 我可以继续：给出 Dexie v10 stores 精确定义、前端升级脚本（默认值补全）、服务端 schema 对齐清单、同步层 `parentUuid` 改造最小改动方案。

- 关键变更影响
  - 统一字段和索引，减少 SchemaDiff 和查询退化；
  - 以 `uuid/parentUuid` 固化外键，杜绝错绑；
  - 版本哨兵与拒写策略，避免回退污染；
  - 索引完善后，历史/分析页面的响应稳定提升。