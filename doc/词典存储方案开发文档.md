# 词典存储方案开发文档

## 1. 项目概述

### 1.1 目标
实现用户上传词典时的智能词汇补充功能，通过官方词汇库自动补充单词的释义、发音、例句等信息，提升用户体验。

### 1.2 核心原则
- **精确匹配**：仅对单词名称进行精确匹配，不做模糊匹配
- **数据分离**：官方数据与用户数据完全分离
- **用户可控**：用户可以编辑任何单词的任何字段
- **性能优先**：支持批量查询，优化大词典处理性能

### 1.3 技术栈
- 后端：Node.js + Express + MongoDB + Mongoose
- 前端：React + TypeScript + Tailwind CSS
- 数据库：MongoDB

## 2. 数据库设计

### 2.1 官方词汇库表 (OfficialWordLibrary)
官方词库在mongoDB的表名：`officialwordlibraries`；
单条记录示例：
{
  "_id": {
    "$oid": "687b1255dab7c489d90ab9be"
  },
  "name": "knock",
  "usphone": "nɑk",
  "ukphone": "nɒk",
  "sentences": [
    {
      "english": "I knocked and knocked but nobody answered.",
      "chinese": "我把门敲了又敲，但无人回应。"
    },
    {
      "english": "He got a nasty knock on the head.",
      "chinese": "他头部遭到重重一击。"
    }
  ],
  "detailed_translations": [
    {
      "pos": "v",
      "chinese": "敲，击，打",
      "english": "to hit a door or window with your closed hand to attract the attention of the people inside"
    },
    {
      "pos": "n",
      "chinese": "敲，击，打",
      "english": "a sharp blow from sth hard"
    }
  ]
}



```typescript
interface IOfficialWordLibrary {
  id: string;                    // 自定义唯一ID
  name: string;                  // 单词名称（小写，精确匹配key）
  usphone: string;               // 美式音标
  ukphone: string;               // 英式音标
  sentences: ISentence[];        // 例句数组
  detailed_translations: IDetailedTranslation[]; // 详细翻译
  createdAt: number;
  updatedAt: number;
}

interface ISentence {
  english: string;               // 英文例句
  chinese: string;               // 中文翻译
}

interface IDetailedTranslation {
  pos: string;                   // 词性 (n, v, adj, adv等)
  chinese: string;               // 中文释义
  english: string;               // 英文释义
}
```

**索引策略**：
```javascript
// 主要查询索引
db.officialwordlibraries.createIndex({ "name": 1 }, { unique: true })


```

### 2.2 自定义单词表 (CustomWord) - 增强版

```typescript
interface ICustomWord {
  id: string;                    // 自定义唯一ID
  dictId: string;                // 关联词典ID
  name: string;                  // 单词名称
  index: number;                 // 在词典中的位置
  
  // 数据来源标识
  sourceType: 'official' | 'user_custom' | 'empty';
  officialWordId?: string;       // 关联官方词汇库ID
  
  // 用户数据（仅在修改或自定义时存储）
  userData?: {
    usphone: string;
    ukphone: string;
    sentences: ISentence[];
    detailed_translations: IDetailedTranslation[];
  };
  
  // 状态标识
  isUserModified: boolean;       // 用户是否修改过
  isEmpty: boolean;              // 是否为空白待填写
  
  createdAt: number;
  updatedAt: number;
}
```

**索引策略**：
```javascript
// 主要查询索引
db.customwords.createIndex({ "dictId": 1, "index": 1 })
db.customwords.createIndex({ "id": 1 }, { unique: true })
db.customwords.createIndex({ "sourceType": 1 })
db.customwords.createIndex({ "officialWordId": 1 })
```

### 2.3 数据存储逻辑

| 场景 | sourceType | officialWordId | userData | isUserModified | isEmpty |
|------|------------|----------------|----------|----------------|---------|
| 匹配到官方数据，未修改 | 'official' | 有值 | undefined | false | false |
| 匹配到官方数据，已修改 | 'official' | 有值 | 完整数据 | true | false |
| 未匹配到，空白待填写 | 'empty' | undefined | undefined | false | true |
| 用户完全自定义 | 'user_custom' | undefined | 完整数据 | true | false |

## 3. 核心服务设计

### 3.1 词汇补充服务 (WordEnrichmentService)

```typescript
class WordEnrichmentService {
  /**
   * 批量词汇补充
   * @param words 用户上传的单词数组
   * @returns 补充结果
   */
  async batchEnrichWords(words: string[]): Promise<EnrichmentResult[]> {
    // 1. 数据清洗
    const cleanWords = words.map(word => word.toLowerCase().trim());
    
    // 2. 批量查询官方词库
    const officialWords = await OfficialWordLibrary.find({
      name: { $in: cleanWords }
    });
    
    // 3. 创建映射表
    const wordMap = new Map(officialWords.map(w => [w.name, w]));
    
    // 4. 生成结果
    return words.map((originalWord, index) => {
      const cleanWord = originalWord.toLowerCase().trim();
      const officialWord = wordMap.get(cleanWord);
      
      return {
        originalWord,
        cleanWord,
        index,
        found: !!officialWord,
        officialData: officialWord || null
      };
    });
  }
}

interface EnrichmentResult {
  originalWord: string;          // 用户原始输入
  cleanWord: string;             // 清洗后的单词
  index: number;                 // 在数组中的位置
  found: boolean;                // 是否在官方库中找到
  officialData: IOfficialWordLibrary | null; // 官方数据
}
```

### 3.2 词典上传处理服务

```typescript
class DictionaryUploadService {
  /**
   * 处理用户词典上传
   * @param words 用户上传的单词数组
   * @param dictId 词典ID
   * @returns 处理结果
   */
  async processWordUpload(words: string[], dictId: string): Promise<UploadResult> {
    // 1. 批量词汇补充
    const enrichmentResults = await this.wordEnrichmentService.batchEnrichWords(words);
    
    // 2. 生成CustomWord记录
    const customWords: ICustomWord[] = enrichmentResults.map(result => {
      if (result.found && result.officialData) {
        // 匹配到官方数据
        return {
          id: generateUUID(),
          dictId,
          name: result.cleanWord,
          index: result.index,
          sourceType: 'official',
          officialWordId: result.officialData.id,
          userData: undefined,
          isUserModified: false,
          isEmpty: false,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
      } else {
        // 未匹配到，创建空记录
        return {
          id: generateUUID(),
          dictId,
          name: result.cleanWord,
          index: result.index,
          sourceType: 'empty',
          officialWordId: undefined,
          userData: undefined,
          isUserModified: false,
          isEmpty: true,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
      }
    });
    
    // 3. 批量保存
    await CustomWord.insertMany(customWords);
    
    // 4. 更新词典信息
    await CustomDictionary.findOneAndUpdate(
      { id: dictId },
      { 
        length: words.length,
        updatedAt: Date.now()
      }
    );
    
    return {
      total: words.length,
      enriched: customWords.filter(w => w.sourceType === 'official').length,
      empty: customWords.filter(w => w.sourceType === 'empty').length,
      words: customWords
    };
  }
}

interface UploadResult {
  total: number;                 // 总词汇数
  enriched: number;              // 成功补充数量
  empty: number;                 // 需要填写数量
  words: ICustomWord[];          // 创建的记录
}
```

### 3.3 词汇查询服务

```typescript
class WordQueryService {
  /**
   * 获取词典的完整单词数据
   * @param dictId 词典ID
   * @returns 完整的单词数据数组
   */
  async getDictionaryWords(dictId: string): Promise<Word[]> {
    // 1. 获取所有CustomWord记录
    const customWords = await CustomWord.find({ dictId }).sort({ index: 1 });

    // 2. 提取需要查询的官方词汇ID
    const officialWordIds = customWords
      .filter(w => w.sourceType === 'official' && !w.isUserModified)
      .map(w => w.officialWordId)
      .filter(Boolean);

    // 3. 批量查询官方数据，每次1000条？
    const officialWords = await OfficialWordLibrary.find({
      id: { $in: officialWordIds }
    });

    // 4. 创建官方数据映射
    const officialWordMap = new Map(officialWords.map(w => [w.id, w]));

    // 5. 合并数据
    return customWords.map(customWord => this.mergeWordData(customWord, officialWordMap));
  }

  /**
   * 合并单词数据
   */
  private mergeWordData(
    customWord: ICustomWord,
    officialWordMap: Map<string, IOfficialWordLibrary>
  ): Word {
    if (customWord.sourceType === 'official' && !customWord.isUserModified) {
      // 使用官方数据
      const officialWord = officialWordMap.get(customWord.officialWordId!);
      return {
        name: customWord.name,
        usphone: officialWord?.usphone ?? '',
        ukphone: officialWord?.ukphone ?? '',
        sentences: officialWord?.sentences ?? [],
        detailed_translations: officialWord?.detailed_translations ?? []
      };
    } else if (customWord.userData) {
      // 使用用户数据
      return {
        name: customWord.name,
        ...customWord.userData
      };
    } else {
      // 空白数据
      return {
        name: customWord.name,
        usphone: '',
        ukphone: '',
        sentences: [],
        detailed_translations: []
      };
    }
  }
}
```

## 4. API接口设计

### 4.1 词典上传API

```typescript
// POST /api/custom-dictionaries/:dictId/words
interface UploadWordsRequest {
  words: string[];               // 用户上传的单词数组
}

interface UploadWordsResponse {
  success: boolean;
  result: {
    total: number;               // 总词汇数
    enriched: number;            // 成功补充数量
    empty: number;               // 需要填写数量
  };
  message?: string;
}
```

### 4.2 单词编辑API

```typescript
// PUT /api/custom-dictionaries/:dictId/words/:wordId
interface UpdateWordRequest {
  usphone?: string;
  ukphone?: string;
  sentences?: ISentence[];
  detailed_translations?: IDetailedTranslation[];
}

interface UpdateWordResponse {
  success: boolean;
  word: ICustomWord;
  message?: string;
}
```

### 4.3 词典查询API

```typescript
// GET /api/custom-dictionaries/:dictId/words
interface GetWordsResponse {
  success: boolean;
  words: Word[];                 // 完整的单词数据
  total: number;
  page: number;
  pageSize: number;
}
```

## 5. 前端界面设计

### 5.1 上传结果展示组件

```typescript
interface UploadResultProps {
  result: UploadResult;
  onEditWord: (wordId: string) => void;
  onBatchEdit: () => void;
}

function UploadResultDisplay({ result, onEditWord, onBatchEdit }: UploadResultProps) {
  return (
    <div className="upload-result">
      {/* 统计信息 */}
      <div className="stats-summary">
        <div className="stat-item">
          <span className="label">总词汇数：</span>
          <span className="value">{result.total}</span>
        </div>
        <div className="stat-item success">
          <span className="label">已自动补充：</span>
          <span className="value">{result.enriched}</span>
        </div>
        <div className="stat-item warning">
          <span className="label">需要编辑：</span>
          <span className="value">{result.empty}</span>
        </div>
      </div>

      {/* 操作按钮 */}
      {result.empty > 0 && (
        <div className="actions">
          <button onClick={onBatchEdit} className="btn-primary">
            批量编辑空白词汇
          </button>
        </div>
      )}

      {/* 词汇列表 */}
      <div className="word-list">
        {result.words.map(word => (
          <WordItem
            key={word.id}
            word={word}
            onEdit={() => onEditWord(word.id)}
          />
        ))}
      </div>
    </div>
  );
}
```

### 5.2 单词编辑组件

```typescript
interface WordEditModalProps {
  word: ICustomWord;
  isOpen: boolean;
  onSave: (data: UpdateWordRequest) => void;
  onClose: () => void;
}

function WordEditModal({ word, isOpen, onSave, onClose }: WordEditModalProps) {
  const [formData, setFormData] = useState({
    usphone: '',
    ukphone: '',
    sentences: [],
    detailed_translations: []
  });

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <div className="word-edit-modal">
        <div className="modal-header">
          <h3>编辑单词：{word.name}</h3>

          {/* 数据来源标识 */}
          <div className="source-badges">
            {word.sourceType === 'official' && (
              <span className="badge official">官方数据</span>
            )}
            {word.sourceType === 'empty' && (
              <span className="badge empty">待填写</span>
            )}
            {word.isUserModified && (
              <span className="badge modified">已修改</span>
            )}
          </div>
        </div>

        <div className="modal-body">
          {/* 音标编辑 */}
          <div className="form-section">
            <h4>音标</h4>
            <div className="form-row">
              <div className="form-group">
                <label>美式音标：</label>
                <input
                  type="text"
                  value={formData.usphone}
                  onChange={(e) => setFormData({...formData, usphone: e.target.value})}
                  placeholder="请输入美式音标"
                />
              </div>
              <div className="form-group">
                <label>英式音标：</label>
                <input
                  type="text"
                  value={formData.ukphone}
                  onChange={(e) => setFormData({...formData, ukphone: e.target.value})}
                  placeholder="请输入英式音标"
                />
              </div>
            </div>
          </div>

          {/* 例句编辑 */}
          <SentenceEditor
            sentences={formData.sentences}
            onChange={(sentences) => setFormData({...formData, sentences})}
          />

          {/* 详细翻译编辑 */}
          <TranslationEditor
            translations={formData.detailed_translations}
            onChange={(translations) => setFormData({...formData, detailed_translations: translations})}
          />
        </div>

        <div className="modal-footer">
          <button onClick={() => onSave(formData)} className="btn-primary">
            保存
          </button>
          <button onClick={onClose} className="btn-secondary">
            取消
          </button>
        </div>
      </div>
    </Modal>
  );
}
```

## 6. 性能优化策略

### 6.1 数据库优化
- **索引策略**：为常用查询字段建立合适的索引
- **批量操作**：使用 `insertMany`、`$in` 等批量操作
- **分页查询**：大词典支持分页加载
- **连接池**：合理配置MongoDB连接池

### 6.2 查询优化
- **批量查询**：一次查询多个官方词汇，减少数据库访问
- **数据缓存**：对热门词汇进行内存缓存
- **懒加载**：前端按需加载词汇详情

### 6.3 前端优化
- **防抖处理**：搜索和编辑操作添加防抖
- **状态管理**：合理使用状态管理避免不必要的重渲染

## 7. 开发计划

### 阶段1：数据库设计与模型创建（1天）
- [ ] 创建 `OfficialWordLibrary` 模型
- [ ] 修改 `CustomWord` 模型
- [ ] 建立数据库索引
- [ ] 编写数据迁移脚本

### 阶段2：核心服务开发（2天）
- [ ] 实现 `WordEnrichmentService`
- [ ] 实现 `DictionaryUploadService`
- [ ] 实现 `WordQueryService`
- [ ] 编写单元测试

### 阶段3：API接口开发（1天）
- [ ] 修改词典上传API
- [ ] 实现单词编辑API
- [ ] 优化词典查询API
- [ ] API文档更新

### 阶段4：前端界面开发（2天）
- [ ] 上传结果展示组件
- [ ] 单词编辑组件
- [ ] 批量编辑功能
- [ ] 用户体验优化

### 阶段5：测试与优化（1天）
- [ ] 功能测试
- [ ] 性能测试
- [ ] 用户体验测试
- [ ] 文档完善

**总计：7天**

## 8. 风险评估与应对

### 8.1 技术风险
- **风险**：大词典查询性能问题
- **应对**：实施分页查询、索引优化、缓存策略

### 8.2 数据风险
- **风险**：官方词库数据质量问题
- **应对**：建立数据验证机制、支持数据更新

### 8.3 用户体验风险
- **风险**：匹配率不高，用户需要大量手动编辑
- **应对**：提供批量编辑工具、优化编辑界面

## 9. 后续扩展计划

### 9.1 短期扩展
- 增加简单的词形变化处理
- 实现批量编辑功能
- 添加数据导入导出功能

### 9.2 长期扩展
- 支持多语言词汇库
- 实现智能建议功能
- 添加词汇质量评估机制

---

**文档版本**：v1.0
**创建日期**：2025-01-18
**最后更新**：2025-01-18
